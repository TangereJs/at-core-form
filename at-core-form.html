<link rel="import" href="schema-helpers-import.html">

<dom-module id="at-core-form">
  <style>
    [class*='col-'] {
      float: left;
      position: relative;
      min-height: 1px;
      padding-left: 15px;
      padding-right: 15px;
      box-sizing: border-box;
    }

    [class*='col-'].col-center {
      float: none;
      margin-left: auto;
      margin-right: auto;
    }

    .col-12 {
      width: 100%;
    }

    .col-9 {
      width: 75%;
    }

    .col-8 {
      width: 66.6666%;
    }

    .col-6 {
      width: 50%;
    }

    .col-5 {
      width: 41.66%;
    }

    .col-4 {
      width: 33.3333%;
    }

    .col-3 {
      width: 25%;
    }

    .col-2 {
      width: 16.6667%;
    }

    .col-1 {
      width: 8%;
    }

    .vertical .col-12 {
      width: 100%;
    }

    .vertical .col-9 {
      width: 100%;
    }

    .vertical .col-8 {
      width: 100%;
    }

    .vertical .col-6 {
      width: 100%;
    }

    .vertical .col-5 {
      width: 41.66%;
    }

    .vertical .col-4 {
      width: 100%;
    }

    .vertical .col-3 {
      width: 50%;
    }

    .vertical .col-2 {
      width: 16.6667%;
    }

    .vertical .col-1 {
      width: 8%;
    }

    .field {
      margin-bottom: 16px;
    }

    #btnTrash {
      cursor: pointer;
    }

    #insertPoint {
      position: relative;
    }

    .clearfix {
      clear: both;
    }

    at-carbon-icon {
      margin-bottom: 6px;
    }

    .wrapper {
      position: relative;
    }
  </style>
  <template>
    <div class="wrapper">
      <at-core-resize-sensor id="resizeSensor"></at-core-resize-sensor>
      <div class="clearfix"></div>
      <div id="insertPoint"></div>
    </div>
    <content></content>
  </template>
</dom-module>

<script>
  'use strict';
  Polymer({
    is: 'at-core-form',
    properties: {
      schema: {
        type: Object,
        value: {
          properties: {}
        },
        observer: 'schemaChanged'
      },
      data: {
        type: Object,
        value: {},
        observer: 'dataChanged'
      },
      valid: {
        type: Boolean,
        notify: true,
        value: true,
        readOnly: true
      },
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged'
      },
      removable: {
        type: Boolean,
        notify: true,
        value: false,
        observer: 'removableChanged'
      },
      // added for #684
      // at-core-form can now have a one column or two column layout
      // by default a two column layout is used but a single column layout can be specified
      // layout === 'horizontal' renders the default two column layout
      // layout === 'vertical' renders the single column layout
      layout: {
        type: String,
        value: "vertical",
        observer: 'layoutChanged'
      }
    },
    _isReady: false,
    _scopeCssViaAttr: true,
    /**
     * This flag is used to prevent value-changed event listener on form elements
     * from updating data property when element's value is supplied from data property
     */
    _isBatchUpdate: false,
    elementsToValidate: [],
    ready: function() {
      this.elementsToValidate = [];
      this._isReady = true;
      this.removableChanged(this.removable, this.removable);
    },
    attached: function () {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
      resizeSensor.addEventListener('resize-sensed', function(event){
        var newWidth = event.detail.value.width;
        // console.log('at-core-form new width: ' + newWidth + 'px');
        coreForm.updateLayout(newWidth);
      });
    },
    updateLayout: function (newWidth, oldWidth) {
        // 377 is from fibonacci sequence; it should do just fine
        if (newWidth < 600) {
          this.layout = "vertical";
        } else {
          this.layout = "horizontal";
        }
    },
    // ------------------------------
    // *ij* maybe one day when we have HTML7 and resize event for elements this function will not be necessary
    // this function is here to solve the problem in at-form-designer
    // when user switches to field settings tab, resize sensor is incorrectly initialized
    // so this function needs to be called to reinitialize the sensor
    resetResizeSensor: function () {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
    },
    // ------------------------------
    schemaChanged: function(newValue, oldValue) {
      if (this._isReady) {
        var self = this;
        var schemaHelpers = window.schemaHelpers;
        self.elementsToValidate = [];

        var fieldsContainer = this.$.insertPoint;
        // clear the previous html content in the container
        Polymer.dom(fieldsContainer).innerHTML = '';

        var
          propertyDefinitions = newValue.properties,
          propertyDefinition,
          defaultValue,
          value,
          xgridcols,
          gridColsCssName,
          fieldContainer,
          formElement,
          displayType;

        Object.keys(propertyDefinitions).forEach(function(propertyName) {
          if (schemaHelpers.isPropertyNameValid(propertyName)) {
            propertyDefinition = propertyDefinitions[propertyName];

            // handle default value
            defaultValue = propertyDefinition.default;
            value = self.data[propertyName];
            // if default value is not null or undefined and regular value is null or undefined
            if (schemaHelpers.notNullOrEmpty(defaultValue) && schemaHelpers.isNullOrEmpty(value)) {
              // make the default value regular value
              self.data[propertyName] = defaultValue;
            }

            // handle xgridcols
            xgridcols = 6;
            if (schemaHelpers.notNullOrEmpty(propertyDefinition.xgridcols)) {
              xgridcols = parseInt(propertyDefinition.xgridcols);
            }

            // create the field container
            fieldContainer = document.createElement('div');
            Polymer.dom(fieldContainer).classList.add('field');
            gridColsCssName = "col-" + xgridcols;
            Polymer.dom(fieldContainer).classList.add(gridColsCssName);

            displayType = schemaHelpers.getDisplayType(propertyDefinition);
            formElement = schemaHelpers.AtFormFactory.createElement(propertyName, displayType, propertyDefinition);

            if (schemaHelpers.isNullOrEmpty(self.data[propertyName])) {
              // at-core-form.data doesn't contain an entry for the current property
              // add initial value of the formElement to the at-core-form.data
              self.data[propertyName] = formElement.value;
            } else {
              // else set initial value from at-core-form.data to fromElement
              if (displayType !== 'file' && displayType !== 'image' && displayType !== 'daterange') {
                formElement.value = self.data[propertyName];
              }
            }
            formElement.addEventListener('value-changed', function(event) {
              // event.stopPropagation();
              if (!self._isBatchUpdate) {
                self._updateDataObject(event.target.id, event.detail.value);
              }
            });

            Polymer.dom(formElement).setAttribute('id', propertyName);
            if (formElement.required) {
              self.elementsToValidate.push(formElement);
            }
            // append paper element to its container
            Polymer.dom(fieldContainer).appendChild(formElement);

            // add container to as child to insertPoint
            Polymer.dom(fieldsContainer).appendChild(fieldContainer);

            // udpate the disabled status
            self.disabledChanged(self.disabled, self.disabled);
          } else {
            console.log('Property name is invalid. Skipping ' + propertyName + ' property');
            console.log('Property definition is:  ', schemaHelpers.formatJson(propertyDefinition));
          }
        });

        // add div class="clearfix"
        var clearfixDiv = document.createElement('div');
        Polymer.dom(clearfixDiv).classList.add('clearfix');
        Polymer.dom(fieldsContainer).appendChild(clearfixDiv);
      }

      this.$.resizeSensor.reset();
    },
    /* *ij*
     OK. Imperative data binding doesn't work in polymer anymore.
     It may happen in the future but not in near future.
     Using at-core-form.data[field] = 'newValue' doesn't work. Its not possible to bind to at-core-form.data[field] to update field value automatically
     Explained in https://github.com/Polymer/polymer/issues/1778 and https://github.com/Polymer/polymer/issues/1796

     So, to solve this shortcoming a updateFormElementData function is introduced
     The purpose of this function is, obviously, to update a value of the specific field.
     This function will update the .data object and .value of the field with provided elementId.
     If the field with provided elementId doesn't exist a debug message will be loged in the console

     Alternative to this approach is to create a completely new object each time you want to update the .data property
     IMO, this approach is a waste of time. An updateFormElementData function is much more efficient

     Another alternative to this approach is to have a function that will return the element itself. Than the client can do whatever he likes with the element
     not just update value. This approach seems reasonable for setFieldState action in at-form-rule-edit
     */
    updateFormElementData: function(elementId, value) {
      var fieldsContainer = this.$.insertPoint,
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + elementId);

      this.data[elementId] = value;
      if (schemaHelpers.valueNotReadOnly(fieldElement)) {
        fieldElement.value = value;
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    setElementState: function(elementId, state, value) {
      var element = Polymer.dom(this.$.insertPoint).querySelector('#' + elementId);
      if (element) {
        element[state] = value;
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    dataChanged: function(newValue, oldValue) {
      var
        fieldsContainer = Polymer.dom(this.$.insertPoint),
        fieldElement;

      this._isBatchUpdate = true;

      if (schemaHelpers.isObject(oldValue)) {
        Object.keys(oldValue).forEach(function(propertyName) {
          if (!newValue.hasOwnProperty(propertyName)) {
            newValue[propertyName] = oldValue[propertyName];
          }
        });
      }

      if (schemaHelpers.isObject(newValue)) {
        Object.keys(newValue).forEach(function(propertyName) {
          fieldElement = fieldsContainer.querySelector('#' + propertyName);
          if (schemaHelpers.valueNotReadOnly(fieldElement)) {
            fieldElement.value = newValue[propertyName];
          }
        });
      } else {
        console.log('at-core-form expects objects as new value, but got ' + schemaHelpers.formatJson(newValue) + ' instead');
      }

      this._isBatchUpdate = false;

      this.fire('data-changed', {
        value: this.data
      });
    },

    /*
     * This function is called on value-changed event for each element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateDataObject: function(property, value) {
      this.data[property] = value;
      this.validate();
      this.fire('data-changed', {
        value: this.data
      });
    },

    /*
     * Validates the form
     * It calls validate method of each element in elementsToValidate array
     * Form is valid if all elements are valid. Form is invalid if at least one element is invalid.
     */
    validate: function() {
      var isValid = true;

      this.elementsToValidate.forEach(function(element){
        if (isFunction(element.validate)) {
          var elementValid = element.validate();
          isValid = isValid && elementValid;
        }
      });

      this._setValid(isValid);

      return isValid;
    },
    disabledChanged: function(newValue, oldValue) {
      var fieldsContainer = this.$.insertPoint,
        fieldElement,
        properties = this.schema.properties;

      Object.keys(properties).forEach(function(propertyName) {
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + propertyName);
        if (fieldElement) {
          if (newValue) {
            fieldElement.disabled = newValue;
          } else {
            fieldElement.disabled = Boolean(properties[propertyName].disabled);
          }
        }
      });
    },
    layoutChanged: function(newValue, oldValue) {
      this.toggleClass('vertical', newValue === 'vertical', this.$.insertPoint);
    },
    removableChanged: function(newValue, oldValue) {
      var btnTrash = this.$.insertPoint.childNodes["btnTrash"];
      if (newValue) {
        if (!btnTrash) {
          btnTrash = document.createElement('div');
          btnTrash.setAttribute('class', 'field col-1');
          btnTrash.setAttribute('style-scope', 'at-core-form');
          btnTrash.id = "btnTrash";

          var btnTrashIcon = document.createElement('at-carbon-icon');
          btnTrashIcon.icon = "trash";
          btnTrashIcon.setAttribute('style-scope', 'at-core-form');
          btnTrashIcon.onclick = this.btnTrashClickHandler;

          btnTrash.appendChild(btnTrashIcon);

          this.$.insertPoint.appendChild(btnTrash);
        }
      } else if (btnTrash) {
        this.$.insertPoint.removeChild(btnTrash);
      }
    },
    btnTrashClickHandler: function() {
      var atCoreForm = this.parentNode.parentNode.parentNode;
      atCoreForm.remove();
      atCoreForm.fire('at-core-form-removed');
    },
    _convertPropertiesToSchemaValues: function(properties) {
      var result = {
          schema: {
            properties: {}
          },
          values: {}
        },
        property,
        propDef,
        innerProp,
        propObj;

      for (property in properties) {
        propObj = result.schema.properties[property] = {};
        propDef = properties[property];
        for (innerProp in propDef) {
          if (innerProp === 'value') {
            result.values[property] = propDef[innerProp];
          } else {
            propObj[innerProp] = propDef[innerProp];
          }
        }
      }

      return result;
    }
  });

  function isFunction(obj) {
    return Object.prototype.toString.apply(obj) === Object.prototype.toString.apply(function() {});
  }
</script>
