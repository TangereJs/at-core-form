

<link rel="import" href="../paper-input/paper-input.html" />
<link rel="import" href="../paper-checkbox/paper-checkbox.html" />
<link rel="import" href="../at-form-lookup/at-form-lookup.html" />
<link rel="import" href="../at-form-toggle/at-form-toggle.html" />

<polymer-element name="at-core-form" attributes="schema data">
  <template>
    <div id="insertPoint"></div>
    <content></content>
  </template>

  <script>
    "use strict";
    Polymer('at-core-form', {
      publish: {
        schema: {},
        data: {},
        valid: true,
        disabled: false
      },
      dataBindingObject: {}, // this object will be used to bind values to form elements; when this.data changes dataBindingObject will be updated and form element values will be udpated automatically
      ready: function () {
        this.dataBindingObject = {};
        this.elementsToValidate = [];
      },
      clear: function () {
        var myNode = this.$.insertPoint;
        while (myNode.firstChild) {
          myNode.removeChild(myNode.firstChild);
        }
      },
      fireDataChangedEvent: function (e) {
        this.fire('data-changed', this.dataBindingObject);
      },
      elementsToValidate: [],
      schemaChanged: function (oldValue, newValue) {
        var self = this;
        self.elementsToValidate = [];

        this.schema = newValue;
        this.clear();
        var properties = this.schema.properties;
        for (var property in properties) {
          var propertyDefinition = properties[property];

          var description = notNullOrUndefined(propertyDefinition.description) ? propertyDefinition.description : property;
          var type = propertyDefinition.type;
          if (type === "string" && propertyDefinition.xtype !== undefined && propertyDefinition.xtype !== null && propertyDefinition.xtype !== "") {
            type = propertyDefinition.xtype;
          }
          var required = propertyDefinition.required === "true" || (this.schema.required && this.schema.required.indexOf(property) !== -1);
          // handle the input mode functionality
          var inputMode = 'optional';
          if (propertyDefinition.xinputmode === undefined && required === true) {
            inputMode = 'required';
          } else {
            inputMode = propertyDefinition.xinputmode !== undefined && propertyDefinition.xinputmode !== '' ? propertyDefinition.xinputmode : inputMode;
          }

          // get the default value and regular value
          var defaultValue = propertyDefinition.default;
          var value = this.data[property];
          // if default value is not null or undefined and regular value is null or undefined
          if (notNullOrUndefined(defaultValue) && !notNullOrUndefined(value)) {
            // make the default value regular value
            this.data[property] = defaultValue;
          }

          if (this.dataBindingObject[property] === undefined) {
            this.dataBindingObject[property] = "";
          }

          var disabledValue = propertyDefinition.disabled !== undefined ? propertyDefinition.disabled : false;
          if (disabledValue === "true") { disabledValue = true; }
          if (disabledValue === "false") { disabledValue = false; }

          var paperElement = undefined;
          var divElem = document.createElement('div');

          if (notNullUndefinedOrEmpty(type)) {
            switch (type) {
              case "string":
              case "number":
                // create paper-input
                paperElement = document.createElement('paper-input-decorator');
                var coreInput = document.createElement('input');
                coreInput.setAttribute('is', 'core-input');

                if (inputMode === 'required') {
                  coreInput.setAttribute('required', true);
                  paperElement.setAttribute('error', 'This input requires a value!');
                  this.elementsToValidate.push(coreInput);
                } else {
                  paperElement.setAttribute(inputMode, true);
                  coreInput.setAttribute(inputMode, true);
                }

                if (type === "number") {
                  coreInput.setAttribute('type', type);
                  paperElement.setAttribute('error', 'Please enter a number!');
                }

                coreInput.bind('value', new PathObserver(this.dataBindingObject, property)); 
                coreInput.addEventListener('change', function (e) {
                  self.updateValidState();
                });

                paperElement.appendChild(coreInput);
                paperElement.id = property;
                paperElement.name = property;
                paperElement.classList.add(property);
                paperElement.label = description;
                paperElement.floatingLabel = true;
                paperElement.setAttribute('disabled', disabledValue);
                if (disabledValue === true) {
                  coreInput.setAttribute('disabled', disabledValue);
                }

                divElem.appendChild(paperElement);
                paperElement.addEventListener('change', function (e) {
                  self.fireDataChangedEvent(e);
                });
                break;
              case "bool":
              case "boolean":
                // create paper-checkbox
                if (propertyDefinition['xtype'] === 'toggle') {
                  paperElement = document.createElement('at-form-toggle');
                } else {
                  paperElement = document.createElement('paper-checkbox');
                }
                
                paperElement.id = property;
                paperElement.name = property;
                paperElement.classList.add(property);
                if (disabledValue === true) {
                  paperElement.setAttribute('disabled', disabledValue);
                }
                paperElement.label = description;
                paperElement.bind('value', new PathObserver(this.dataBindingObject, property));
                divElem.appendChild(paperElement);
                paperElement.addEventListener('core-change', function (e) {
                  self.fireDataChangedEvent(e);
                });
                break;
              case "enum":
                paperElement = document.createElement('at-form-lookup');
                paperElement.id = property;
                paperElement.name = property;
                paperElement.classList.add(property);
                paperElement.setAttribute('disabled', disabledValue);
                paperElement.label = description;
                paperElement.available = propertyDefinition['xvaluelist'];
                divElem.appendChild(paperElement);
                paperElement.bind('value', new PathObserver(this.dataBindingObject, property));
                paperElement.addEventListener('change', function (e) {
                  self.fireDataChangedEvent(e);
                });
                this.elementsToValidate.push(paperElement);
                break;
              case "lookup":
                paperElement = document.createElement('at-form-lookup');
                paperElement.id = property;
                paperElement.name = property;
                paperElement.classList.add(property);
                paperElement.label = description;
                paperElement.setAttribute('disabled', disabledValue);
                paperElement.url = propertyDefinition['xurl'];
                if (paperElement.url !== undefined) {
                  //paperElement.setAttribute('preload', true);
                  paperElement.setAttribute('params', '{"query":""}');
                }
                //paperElement.setAttribute('usedropdown', true);
                if (propertyDefinition['withCredentials'] !== undefined) {
                  paperElement.setAttribute('withCredentials', true);
                }
                divElem.appendChild(paperElement);
                paperElement.bind('value', new PathObserver(this.dataBindingObject, property));
                paperElement.addEventListener('change', function (e) {
                  self.fireDataChangedEvent(e);
                });
                break;
            }
            this.$.insertPoint.appendChild(divElem);
          } else {
            console.log("Property " + property + " doens't have defined type. Skipping ...");
          }
        }

        // copy all values from data property to dataBindingObject property
        //copyPropertyValues(this.dataBindingObject, this.data);

        // create object observer on dataBindingObject
        // when dataBindingObject is updated we update data property
        // this enables data property to be used outside the component for getting the data values
        var dbObjObserver = new ObjectObserver(this.dataBindingObject);
        dbObjObserver.open(function (added, removed, changed, getOldValueFn) {
          Object.keys(changed).forEach(function (property) {
            self.data[property] = self.dataBindingObject[property];
          });
        });
      },
      dataChanged: function (oldValue, newValue) {
        for (var entry in this.data) {
          this.dataBindingObject[entry] = this.data[entry];
        }
      },
      updateValidState: function () {
        var closureThis = this;
        setTimeout(function () {
          closureThis.valid = true;
          //console.clear();
          for (var i = 0; i < closureThis.elementsToValidate.length; i++) {
            var element = closureThis.elementsToValidate[i];
            if (element.checkValidity !== undefined) {
              var isValid = element.checkValidity();
              element.parentElement.isInvalid = !isValid;
              closureThis.valid = closureThis.valid && isValid;
              //console.log("Element " + element.name + " is " + isValid);
            }
          }
        }, 100);
      },
      disabledChanged: function () {
        for (var property in this.schema.properties) {
          var element = this.$.insertPoint.querySelector('.' + property);
          var disabledValue = this.disabled;
          if (this.disabled === false) {
            var elemDisabledValue = this.schema.properties[element.id].disabled;
            if (elemDisabledValue !== undefined && (elemDisabledValue === "true" || elemDisabledValue === true)) {
              disabledValue = true;
            }
          }
          element.setAttribute('disabled', disabledValue);
          var childInput = element.querySelector('input');
          if (notNullOrUndefined(childInput)) {
            if (disabledValue === false) {
              childInput.removeAttribute('disabled');
            } else {
              childInput.setAttribute('disabled', true);
            }
          }
        }
      },
    });

    function notNullOrUndefined(param) {
      return (param !== null) && (param !== undefined)
    }

    function notNullUndefinedOrEmpty(param) {
      return notNullOrUndefined(param) && (param !== '');
    }

    function isObject(obj) {
      return Object.prototype.toString.call(obj) === Object.prototype.toString.call({});
    }

    function copyPropertyValues(from, to) {
      if (isObject(from) && isObject(to)) {
        for (var property in from) {
          to[property] = from[property];
        }
      }
    }
  </script>
</polymer-element>
