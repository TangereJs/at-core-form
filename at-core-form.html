<link rel="import" href="../tangere/tangere.html">
<!-- <link rel="import" href="../at-elements/at-designer-elements.html"> -->
<link rel="import" href="../at-core-schema/at-core-schema.html">
<link rel="import" href="../at-core-resize-sensor/at-core-resize-sensor.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors-rules-evaluation.html">
<link rel="import" href="../at-rule-engine/at-rule-engine.html">

<dom-module id="at-core-form">
  <template>
    <style include="at-form-common"></style>
    <style>
      .at-core-form-wrapper {
        position: relative;
        margin-top: 16px;
      }

      :host(:focus) {
        outline: none;
      }

      #insertPoint {
        position: relative;
      }

      at-form-checkbox {
        min-height: 76px;
      }
      /* workaround for IE11 flexbox min-height bug */

      _:-ms-fullscreen,
      at-form-checkbox::before {
        content: "";
        display: inline-block;
        min-height: 38px;
        visibility: hidden;
      }

      .vertical .col-6.at-form-checkbox {
        min-height: 32px;
        margin-bottom: 18px;
      }

      .vertical .col-6 at-form-checkbox {
        min-height: 32px;
      }
      /* workaround for IE11 flexbox min-height bug */

      _:-ms-fullscreen,
      .vertical .col-6 at-form-checkbox::before {
        content: "";
        display: inline-block;
        min-height: 16px;
        visibility: hidden;
      }
    </style>
    <div class="at-core-form-wrapper">
      <at-core-resize-sensor id="resizeSensor"></at-core-resize-sensor>
      <div class="clear-float"></div>
      <div id="insertPoint"></div>
    </div>
    <content></content>
  </template>
</dom-module>

<script>
  'use strict';
  Polymer({
    is: 'at-core-form',
    hostAttributes: {
      tabindex: 0
    },
    behaviors: [Tangere.behaviors.RulesEvaluation],
    properties: {
      /**
       * Specification of elements that should appear on the form.<br/>
       * Provide either an object or string.<br/>
       * List property definitions inside properties object.<br/>
       *
       * @property schema
       * @type Object | Stirng
       * @default { properties: {} }
       */
      schema: {
        type: Object,
        value: function() {
          var result = {
            properties: {}
          };
          return result;
        },
        observer: '_schemaChanged'
      },
      /**
       * Holds values of the elements on the form
       *
       * @property data
       * @type Object | String
       * @default {}
       */
      data: {
        type: Object,
        value: function() {
          return {};
        },
        observer: '_dataChanged'
      },
      files: {
        type: Object,
        value: function() {
          return {};
        },
        observer: 'filesChanged'
      },
      /**
       * When true disables all elements on the form
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: '_disabledChanged'
      },
      /**
       * When true hides all elements.
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged'
      },
      /**
       * Valid state of the form. When all elements on the form are valid form is valid. If at least one element on the form is invalid, form is invalid
       * @property valid
       * @type Boolean
       * @default true
       */
      // valid: {
      //   type: Boolean,
      //   notify: true,
      //   value: true,
      //   readOnly: true
      // },
      /**
       * at-core-form can now have a one column or two column layout <br/>
       * by default a one column layout is used but a two column layout can be specified <br/>
       * layout = 'horizontal' renders the two column layout <br/>
       * layout = 'vertical' renders the single column layout <br/>
       *
       * @property layout
       * @type string
       * @default vertical
       */
      // added for #684
      layout: {
        type: String,
        value: "vertical",
        observer: '_layoutChanged',
        xtype: "enum",
        available: "horizontal,vertical"
      }
    },
    get valid() {
      return this.validate(false);
    },
    set valid(newValue) {},

    ready: function() {
      this._elementsToValidate = [];
      this._isReady = true;
    },

    attached: function() {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
      resizeSensor.addEventListener('resize-sensed', function(event) {
        var newWidth = event.detail.value.width;
        // console.log('at-core-form new width: ' + newWidth + 'px');
        coreForm.updateLayout(newWidth);
      });
    },

    updateLayout: function(newWidth, oldWidth) {
      if (newWidth < 600) {
        this.layout = "vertical";
      } else {
        this.layout = "horizontal";
      }
    },

    /**
     * Focuses the element on the form with given elementId
     * If elementId is provided and element with provided elementId exists, its focused.
     * If elementId is not provided first element on the form is focused
     */
    setFocus: function (elementId) {
      var _sh = window.schemaHelpers;
      if (!_sh.isObject(this.schema) || !_sh.isObject(this.schema.properties)) {
        return;
      }

      // postpone focus setting until rendering is finished
      if (this._rendering) {
        this._setFocusPending = true;
        this._setFocusElementId = elementId;
        return;
      }

      var element;
      if (_sh.isString(elementId) && elementId !== "") {
        element = this.getElement(elementId);
      } else {
        // focus first element on the form
        var propertyNames = Object.getOwnPropertyNames(this.schema.properties);
        var firstElementName = propertyNames[0];
        element = this.getElement(firstElementName);
      }

      if (element !== null && _sh.isFunction(element.focus)) {
        element.focus();
      }
    },

    _hideChanged: function(newValue, oldValue) {
      var self = this;
      var insertPoint = this.$.insertPoint;
      var parsedValue = schemaHelpers.parseBool(newValue);

      if (this.schema && this.schema.properties) {
        var properties = this.schema.properties;
        var propNames = Object.getOwnPropertyNames(properties);
        propNames.forEach(function(propName, index) {
          var formElement = self.getElement(propName);
          if (formElement) {
            self.toggleClass('hidden', parsedValue, formElement.parentElement);
            formElement.hide = parsedValue;
          }
        });
      }
    },
    // ------------------------------
    // *ij* maybe one day when we have HTML7 and resize event for elements this function will not be necessary
    // this function is here to solve the problem in at-form-designer
    // when user switches to field settings tab, resize sensor is incorrectly initialized
    // so this function needs to be called to reinitialize the sensor
    resetResizeSensor: function() {
      var resizeSensor = this.$.resizeSensor;
      var coreForm = this;
      resizeSensor.reset();
      var currWidth = resizeSensor.queryWidth();
      coreForm.updateLayout(currWidth);
    },


    _schemaChanged: function (newValue, oldValue) {
      var _sh = window.schemaHelpers;

      if (_sh.isString(newValue)) {
        /*
        if newValue for schema is given as json string, parse it and assign it to this.schema
        if newValue is a valid json string this.schema will trigger _schemaChanged again so we return to prevent schema changes being applied twice
        if newValue is an invalid json string just return. Whatever the previous schema was that remains visible to the user
        */
        try {
          newValue = JSON.parse(newValue);
          this.schema = newValue;
        } catch (e) {
          console.log(e);
        }
        return;
      }

      // check if newValue is valid schema object
      // if its invalid whatever the previous schema was that remains visible to the user
      if (!_sh.isObject(newValue) || !_sh.isObject(newValue.properties)) {
        return;
      }

      // set flag to indicate that rendering is currently active
      this._rendering = true;

      // figure out the list of the elements that should be imported
      schemaHelpers.initializeCentralArrayOfComponents();
      var _properties = newValue.properties;
      var _propertyNames = Object.getOwnPropertyNames(newValue.properties);
      var nonImportedElements = [];

      _propertyNames.forEach(function (propName, index) {
        var propDef = _properties[propName];
        var displayType = schemaHelpers.getDisplayType(propDef, []);
        var mapping = schemaHelpers.findMapping(displayType);

        if (!mapping) {
          // element is not loaded; scheadule it for importHref
          propDef.displayType = displayType;
          nonImportedElements.push(propDef);
        }
      });

      var displayTypeToFormElementMapping = {
        array: "at-form-array",
        boolean: "at-form-checkbox",
        toggle: "at-form-checkbox",
        code: "at-form-codemirror",
        json: "at-form-codemirror",
        object: "at-form-complex",
        date: "at-form-date",
        time: "at-form-date",
        datetime: "at-form-date",
        daterange: "at-form-daterange",
        file: "at-form-file",
        image: "at-form-image",
        'enum': "at-form-lookup",
        lookup: "at-form-lookup",
        marked: "at-form-markdown",
        password: "at-form-password",
        number: "at-form-number",
        radio: "at-form-radio",
        section: "at-form-section",
        state: "at-form-state",
        string: "at-form-text",
        textarea: "at-form-textarea"
      };

      var self = this;
      if (nonImportedElements.length) {
        var pendingImportsCount = nonImportedElements.length;

        nonImportedElements.forEach(function (propDef, index) {
          // To construct elemHref we need static information about what (type, xtype) maps to which at-form element
          // Right now, only $meta in each element contains this information and central array of components is populated with $meta information
          // So, to dynamically importHref needed elements we need to introduce static information (which will just be a copy paste from $meta of each element)

          var displayType = propDef.displayType;
          var elementName = displayTypeToFormElementMapping[displayType];

          // construct elemHref
          var compUrl = document.baseURI.indexOf("/components/") >= 0 ? "/components/" : "components/";

          if (document.URL.indexOf("/elements/designer-element/") >= 0) {
            compUrl = "/components/";
          }

          if (window.ComponentsBase != undefined) {
            compUrl = window.ComponentsBase;
          }
          var elemHref = compUrl + elementName + "/" + elementName + ".html";

          self.importHref(elemHref, function(e) {
            // import was successful
            pendingImportsCount -= 1;
            if (!pendingImportsCount) {
              self._renderSchema(newValue);
            }
          }, function (e) {
            // import failed
            console.log("import failed: " + e.target.href);
          });
        });
      } else {
        self._renderSchema(newValue);
      }
    },

    // ------------------------------
    _renderSchema: function(newValue, oldValue) {
      // cache the reference to at-core-schema.schemaHelpers
      var _sh = window.schemaHelpers;

      // if data is set before schema, this._internalData is already updated
      // if schema is set first this._internalData is undefined so its initialized to empty object
      if (!this._internalData) {
        this._internalData = {};
      }

      var self = this;
      // calculating valid state for the form is faster if we cache references to each element on the form
      // its even faster if we exclude elements that do not have valid property
      self._elementsToValidate = [];

      // right now at-core-form supports all elements
      if (!_sh.isArray(self._unsupported_types)) {
        self._unsupported_types = [];
      }

      var fieldsContainer = this.$.insertPoint;
      // clear the previous html content in the container
      // we do not use Polymer.dom(fieldsContainer).innerHTML = "" because innerHTML invokes browser's html parser which is more expensive than removing nodes
      while (Polymer.dom(fieldsContainer).firstChild) {
        Polymer.dom(fieldsContainer).removeChild(Polymer.dom(fieldsContainer).firstChild);
      }

      var fieldsFragment = document.createDocumentFragment();
      var divPrototype = document.createElement('div');
      var propertyNames = Object.getOwnPropertyNames(newValue.properties);
      var propertyDefinition;
      var defaultValue;
      var containsProperty;
      var displayType;
      var xgridcols;
      var gridColsCssName;
      var fieldContainer;
      var formElement;

      propertyNames.forEach(function(propertyName) {
        if (schemaHelpers.isPropertyNameValid(propertyName)) {
          propertyDefinition = newValue.properties[propertyName];

          // handle default value
          defaultValue = propertyDefinition.default;
          containsProperty = self._internalData.hasOwnProperty(propertyName);
          // if default value is defined and _internalData[propertyName] value is undefiend put default value into self._internalData
          if (defaultValue !== undefined && !containsProperty) {
            self._internalData[propertyName] = defaultValue;
          }

          displayType = schemaHelpers.getDisplayType(propertyDefinition, self._unsupported_types);

          // handle xgridcols
          xgridcols = displayType === "section" ? 12 : 6;
          if (_sh.isString(propertyDefinition.xgridcols)) {
            var parseResult = parseInt(propertyDefinition.xgridcols);
            if (!window.isNaN(parseResult)) {
              xgridcols = parseResult;
            }
          }

          // create element for field
          formElement = schemaHelpers.createElement(propertyName, displayType, propertyDefinition);

          // enable autoValidate for all form elements
          formElement.autoValidate = true;

          // create the field container
          fieldContainer = divPrototype.cloneNode(true);
          gridColsCssName = "col-" + xgridcols;
          Polymer.dom(fieldContainer).classList.add(gridColsCssName);

          // special container for at-form-toggle to allow smaller height in vertical mode
          if (formElement.tagName.toLowerCase() == "at-form-checkbox") {
            Polymer.dom(fieldContainer).classList.add("at-form-checkbox");
          }

          if (!self._internalData.hasOwnProperty(propertyName)) {
            // at-core-form._internalData doesn't contain an entry for the current property
            // add initial value of the formElement to the at-core-form.data
            self._internalData[propertyName] = formElement.value;
            if (_sh.isObject(formElement.value) || _sh.isArray(formElement.value)) {
              self._internalData[propertyName] = JSON.parse(JSON.stringify(formElement.value));
            }
          } else {
            // else set initial value from at-core-form.data to fromElement
            formElement.value = self._internalData[propertyName];
            if (_sh.isObject(self._internalData[propertyName]) || _sh.isArray(self._internalData[propertyName])) {
              formElement.value = JSON.parse(JSON.stringify(self._internalData[propertyName]));
            }
          }

          if (_sh.isFunction(formElement.clearUIValidState)) {
            // at-form-section doesn't have clearUIValidState function nor does it need one
            formElement.clearUIValidState();
          } else if (_sh.isFunction(formElement._clearUIValidState)) {
            formElement._clearUIValidState();
          }

          formElement.addEventListener('value-changed', function(event) {

            if (event.target.files) {
              self._updateFilesObject(event.target.id, event.target.files);
            }

            var id = event.target.id;
            var newValue = event.detail.value;
            var currentValue = self._internalData[id];
            if (!_sh.areEqual(currentValue, newValue)) {
              self._updateDataObject(id, newValue);
            }

          });

          Polymer.dom(formElement).setAttribute('id', propertyName);
          // do not put at-form-section into elementsToValidate because validation doesn't make sense for at-form-section
          if ([ "section" ].indexOf(displayType) < 0) {
            self._elementsToValidate.push(formElement);
          }


          // if at-core-form is initially hidden, element should be hidden as well
          formElement.hide = self.hide || _sh.parseBool(propertyDefinition.hide);

          // if at-core-form is initially disabled, element should be disabled as well
          formElement.disabled = self.disabled || _sh.parseBool(propertyDefinition.disabled);

          // append element to its container
          Polymer.dom(fieldContainer).appendChild(formElement);

          // add container to as child to insertPoint
          Polymer.dom(fieldsFragment).appendChild(fieldContainer);
        } else {
          console.log('Property name is invalid. Skipping ' + propertyName + ' property');
          console.log('Property definition is:  ', schemaHelpers.formatJson(propertyDefinition));
        }
      });

      if (_sh.isObject(self.data)) {
        // if data was set first there is a chance that some properties form this._internalData are missing in this.data
        // this.data must be updated with missing properties
        var internalDataKeys = Object.getOwnPropertyNames(this._internalData);
        internalDataKeys.forEach(function (key, index) {
          // self.data[key] === undefined means that the key is missing from self.data
          if (!self.data.hasOwnProperty(key)) {
            self.data[key] = self._internalData[key];
          }
        });
      }

      // add div class="clearfix"
      var clearfixDiv = divPrototype.cloneNode(true);
      Polymer.dom(clearfixDiv).classList.add('clearfix');
      Polymer.dom(fieldsFragment).appendChild(clearfixDiv);

      Polymer.dom(fieldsContainer).appendChild(fieldsFragment);

      // if any element is required in schema its valid state is updated after creation
      // at-core-form needs to reflect that state
      self._calculateFormValidState();

      // since elements are added to at-core-form html, reset resize sensor so that it picks up new at-core-form width and height
      var resizeSensor = this.$.resizeSensor;
      resizeSensor.reset();

      var width = resizeSensor.queryWidth();
      self.updateLayout(width);

      // evaluate rules against new schema
      if (propertyNames.length) {
        self._executeRuleEvaluation(newValue);
      }

      this._rendering = false; // clearing flag indicating an active rendering process

      // set pending focus 
      if (this._setFocusPending) {       
        this.setFocus(this._setFocusElementId);
        delete this._setFocusPending;
        delete this._setFocusElementId;
      }

      self.fire('rendered', this, { bubbles: false });
    },

    _executeRuleEvaluation: function (schema) {
      var _sh = window.schemaHelpers;
      if (this._isBusinessRulesEvaluationInProgress) {
        return;
      }
      this._isBusinessRulesEvaluationInProgress = true;
      if (_sh.isArray(schema.rules) && schema.rules.length) {

        // what is happening here? Please note that steps are explained in reverse order because of dependencies
        // 3. Why do we reset _rulesEvaluator every time
        // Because _rulesEvaluator remembers last data it evaluated rules against
        // if data is the same rules are not evaluated
        // this means that if user doesn't change default values for elements between rule Editing and preview,
        // updated rules will not be initially executed, but its expected that rules be executed
        this._rulesEvaluator = new RulesEvaluator();

        // 2. Why do we reset active schema every time?
        // Because, activeSchema is cached as a private variable in at-form-behaviors-rules-evaluation so its saved between schema changes,
        var activeSchema = {
          properties: {}
        };
        activeSchema.properties = JSON.parse(JSON.stringify(schema.properties));
        this._activeSchema = activeSchema;

        // 1. Its expected to display the results of rules evaluation when new schema is set
        // at-core-form invokes rule evaluation when any element on the form changes value;
        // its not really desirable to invoke rule evaluation that way, since we have access to at-form-behaviors-rules-evaluation._evaluateRules function
        // but to invoke evaluate rules we need a property and its value; so we provide first property on the form and its value
        var propNames = Object.getOwnPropertyNames(schema.properties);
        var propName = propNames[0];
        var propValue = this.getElement(propName).value;
        this._evaluateRules(propName, propValue);

        // 1a. Why do we clear ui valid state of the elements
        // Because its expected that initially UI errors are not displayed. Errors should be displayed only when user interacts with the element(s)
        var self = this;
        propNames.forEach(function(propName, index) {
          var element = self.getElement(propName);
          element._clearUIValidState();
        });
      }
      this._isBusinessRulesEvaluationInProgress = false;
    },

    /* *ij*
     OK. Imperative data binding doesn't work in polymer anymore.
     It may happen in the future but not in near future.
     Using at-core-form.data[field] = 'newValue' doesn't work. Its not possible to bind to at-core-form.data[field] to update field value automatically
     Explained in https://github.com/Polymer/polymer/issues/1778 and https://github.com/Polymer/polymer/issues/1796

     So, to solve this shortcoming a updateFormElementData function is introduced
     The purpose of this function is, obviously, to update a value of the specific field.
     This function will update the .data object and .value of the field with provided elementId.
     If the field with provided elementId doesn't exist a debug message will be loged in the console

     Alternative to this approach is to create a completely new object each time you want to update the .data property
     IMO, this approach is a waste of time. An updateFormElementData function is much more efficient

     Another alternative to this approach is to have a function that will return the element itself. Than the client can do whatever he likes with the element
     not just update value. This approach seems reasonable for setFieldState action in at-form-rule-edit
     */
    updateFormElementData: function(elementId, value) {
      var fieldElement = this.getElement(elementId);
      if (!fieldElement) {
        // console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
        return;
      }

      this.data[elementId] = value;

      fieldElement.value = value;
      // *ij* polymer js doesn't call valueChanged if value is of type array or object
      // we check for this situation and call valueChanged by hand
      if (schemaHelpers.isObject(fieldElement.value) || schemaHelpers.isArray(fieldElement.value)) {
        if (fieldElement.valueChanged) {
          fieldElement.valueChanged(value, undefined);
        } else if (fieldElement._valueChanged) {
          fieldElement._valueChanged(value, undefined);
        }
      }
    },

    setElementState: function(elementId, state, value) {
      var element = this.getElement(elementId);
      if (!element) {
        // console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
        return;
      }

      element[state] = value;
    },

    getElement: function(elementId) {
      var insertPoint = this.$.insertPoint;
      var selector = '#' + elementId;
      var element = Polymer.dom(insertPoint).querySelector(selector);

      return element;
    },

    _dataChanged: function(newValue, oldValue) {
      var _sh = window.schemaHelpers;

      if (_sh.isString(newValue)) {
        /*
          if newValue for data is given as json string, parse it and assign it to this.data
          if newValue is a valid json string this.data will trigger _dataChanged again so we return to prevent data changes being applied twice
          if newValue is an invalid json string just return. Whatever the previous data was that remains visible to the user
        */
        try {
          newValue = JSON.parse(newValue);
          this.data = newValue;
        } catch (e) {
          console.log(e);
        }
        return;
      }

      // if new value is not an object, ignore the value and return
      if (!_sh.isObject(newValue)) {
        console.log('at-core-form expects objects as new value, but got ' + _sh.formatJson(newValue) + ' instead');
        return;
      }

      // initalize _internalData object; this objects holds last valid data set to at-core-form
      if (!this._internalData) {
        this._internalData = {};
      }
      var _internalData = this._internalData;

      // update _internalData with keys from newValue
      var newValueKeys = Object.getOwnPropertyNames(newValue);
      newValueKeys.forEach(function (key, index) {
        _internalData[key] = newValue[key];
        if (_sh.isObject(newValue[key]) || _sh.isArray(newValue[key])) {
          _internalData[key] = JSON.parse(JSON.stringify(newValue[key]));
        }
      });

      if (!_sh.isObject(this.schema) || !_sh.isObject(this.schema.properties) || Object.getOwnPropertyNames(this.schema.properties).length === 0) {
        // when schema is not set data-changed event should still be fired so that behavior is the same as when schema is set
        this.fire('data-changed', {
          value: this.data
        });
        // this means that schema is not set and at-core-form is not initialized; return
        return;
      }

      // at this point this._internalData contains updated values for each element on the form because
      // 1) if schema was set first, this._internalData was already populated with initial values for each element,
      //    and entries from newValue are merged into this._internalData
      // 2) if data was set first, properties from this._internalData may be missing in this.data so they need to be copied over
      //    but this is done in _schemaChanged

      var fieldsContainer = Polymer.dom(this.$.insertPoint);
      var fieldElement;
      var self = this;
      // use newValueKeys here because only keys from newValue are the ones changing
      newValueKeys.forEach(function(propertyName) {
        fieldElement = self.getElement(propertyName);
        if (fieldElement) {
          fieldElement.value = newValue[propertyName];
          if (_sh.isObject(newValue[propertyName]) || _sh.isArray(newValue[propertyName])) {
            fieldElement.value = JSON.parse(JSON.stringify(newValue[propertyName]));
          }
        }
      });

      // newValue can contain only a subset of properties on the form
      // value in data-changed should contain all properties so we need to copy over missing properties from _internalData
      var internalDataKeys = Object.getOwnPropertyNames(this._internalData);
      internalDataKeys.forEach(function (key, index) {
        if (!self.data.hasOwnProperty(key)) {
          self.data[key] = self._internalData[key];
          if (_sh.isObject(self._internalData[key]) || _sh.isArray(self._internalData[key])) {
            self.data[key] = JSON.parse(JSON.stringify(self._internalData[key]));
          }
        }
      });

      if (_sh.isObject(this.schema) && _sh.isObject(this.schema.properties) && Object.getOwnPropertyNames(this.schema.properties).length) {
        self._executeRuleEvaluation(this.schema);
      }

      this._calculateFormValidState();
      this.fire('data-changed', {
        value: this.data
      }, {
        bubbles: false
      });
    },

    /*
     * This function is called on value-changed event for each element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateDataObject: function(property, value) {
      var _sh = window.schemaHelpers;
      this._internalData[property] = value;
      if (_sh.isArray(this.schema.rules) && this.schema.rules.length > 0) {
        if (!this._isBusinessRulesEvaluationInProgress) {
          this._isBusinessRulesEvaluationInProgress = true;
          this._evaluateRules(property, value);
          this._isBusinessRulesEvaluationInProgress = false;
        } else {
          return;
        }
      } else {
        this.data[property] = value;

        if (_sh.isObject(value) || _sh.isArray(value)) {
          var valueClone = JSON.parse(JSON.stringify(value));
          this._internalData[property] = valueClone;
          this.data[property] = valueClone;
        }
      }

      this._calculateFormValidState();
      this.fire('data-changed', {
        property: property,
        value: this.data
      },{
        bubbles: false
      });
    },

    filesChanged: function(newValue, oldValue) {
      //var fieldsContainer = Polymer.dom(this.$.insertPoint);
      //var fieldElement;
      //var properties = this.schema.properties;
      //var initialData = this._calculateInitialDataFromSchemaProperties(properties);

      //if (schemaHelpers.isString(newValue)) {
      //    try {
      //        newValue = JSON.parse(newValue);
      //        this.data = newValue;
      //        return;
      //    } catch (e) {
      //        console.log(e);
      //    }
      //}

      //this._isBatchUpdate = true;

      //if (schemaHelpers.isObject(oldValue)) {
      //    Object.getOwnPropertyNames(initialData).forEach(function(propertyName) {
      //        if (!newValue.hasOwnProperty(propertyName)) {
      //            newValue[propertyName] = initialData[propertyName];
      //        }
      //    });
      //}

      //if (schemaHelpers.isObject(newdeValue)) {
      //    Object.getOwnPropertyNames(newValue).forEach(function(propertyName) {
      //        fieldElement = fieldsContainer.querySelector('#' + propertyName);
      //        if (schemaHelpers.valueNotReadOnly(fieldElement)) {
      //            fieldElement.value = newValue[propertyName];
      //        }
      //    });
      //} else {
      //    console.log('at-core-form expects objects as new value, but got ' + schemaHelpers.formatJson(newValue) + ' instead');
      //}

      //this._isBatchUpdate = false;
      //this._calculateFormValidState();
      //this.fire('data-changed', {
      //    value: this.data
      //});
    },

    /*
     * This function is called on value-changed event for each element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateFilesObject: function(property, value) {
      this.files[property] = value;
      this._calculateFormValidState();
      this.fire('files-changed', {
        property: property,
        value: this.files
      });
    },

    _calculateFormValidState: function() {
      var isValid = true;

      this._elementsToValidate.forEach(function(element) {
        if (!(element.disabled  || element.hide)) {
          var elementValid = element.valid;
          isValid = isValid && elementValid;
        }
      });

      // this._setValid(isValid);

      return isValid;
    },

    /*
     * Validates the form and shows errors for invalid elements
     * It calls validate method of each element in _elementsToValidate array
     * Form is valid if all elements are valid. Form is invalid if at least one element is invalid.
     */
    validate: function() {
      var isValid = true;

      this._elementsToValidate.forEach(function(element) {
        if (!(element.disabled || element.hide)) {
          var elementValid = element.validate(true);
          isValid = isValid && elementValid;
        }
      });

      // this._setValid(isValid);

      return isValid;
    },

    _disabledChanged: function(newValue, oldValue) {
      var fieldsContainer = this.$.insertPoint;
      var fieldElement;
      var properties = this.schema.properties;
      var propertyNames = properties ? Object.getOwnPropertyNames(properties) : [];
      var parsedValue = schemaHelpers.parseBool(newValue);

      propertyNames.forEach(function(propertyName) {
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + propertyName);
        if (fieldElement) {
            fieldElement.disabled = parsedValue || schemaHelpers.parseBool(properties[propertyName].disabled);
        }
      });

      if (this._isReady) {
        this._calculateFormValidState();
      }
    },
    _layoutChanged: function(newValue, oldValue) {
      this.toggleClass('vertical', newValue === 'vertical', this.$.insertPoint);
    },
    _convertPropertiesToSchemaValues: function(properties) {
      var result = {
          schema: {
            properties: {}
          },
          values: {}
        },
        property,
        propDef,
        innerProp,
        propObj;

      for (property in properties) {
        propObj = result.properties[property] = {};
        propDef = properties[property];
        for (innerProp in propDef) {
          if (innerProp === 'value') {
            result.values[property] = propDef[innerProp];
          } else {
            propObj[innerProp] = propDef[innerProp];
          }
        }
      }

      return result;
    },
    /**
     * This function is created for task #773 at-core-form .data handling
     * this function creates initial data object from schema properties
     * value for each entry is either default value from element or default value from schema (specified with default: '<value>')
     * _dataChanged function calls this function
     */
    _calculateInitialDataFromSchemaProperties: function(properties) {
      var insertPoint = this.$.insertPoint;
      var result = {};
      var propertyNames = properties ? Object.getOwnPropertyNames(properties) : [];
      var propSchemaDef;
      var calculatedValue;

      propertyNames.forEach(function(propName, index) {
        propSchemaDef = properties[propName];

        // if .default exists in propSchemaDef that is the calculatedValue
        if (propSchemaDef.default !== undefined) {
          calculatedValue = propSchemaDef.default;
        } else {
          // form is already created; query the self.$.insertPoint and get default value from element.properties.value.value
          var element = Polymer.dom(insertPoint).querySelector('#' + propName);
          if (element.properties.value !== undefined && element.properties.value.value !== undefined) {
            // at-form-section doesn't have value property nor does it need one
            calculatedValue = element.properties.value.value;
          }
        }

        result[propName] = calculatedValue;
      });

      return result;
    }

  });
</script>
